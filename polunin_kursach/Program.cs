using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace polunin_kursach
{
    class Program
    {
        static void Main(string[] args)
        {
            // Истинные параметры движения КА (они же начальные условия в
            // уравнениях движения КА, "y0s" в RungeCutta)
            //
            // Указаны в задании, но можно менять
            double xk_real = -6e6;
            double yk_real = 6e6;
            double vx_real = 5000;
            double vy_real = 5000;

            // Цена оборудования (по заданию, один из случаев)
            double equipmentCost = 5e5;
            // Цена одного измерения (по заданию, один из случаев)
            double gaugingCost = 4e2;
            // Цена подготовки исходных данных для одного ориентира (по заданию, один из случаев)
            double landmarkCost = 2e4;

            // Задаем интервал измерений (время в секундах)
            //
            // Минимальный интервал указан в задании, можно менять
            int interval = 3;

            // Задаем количество измерений
            int gaugingCount = 400;


            // Задаем количество ориентиров
            int landmarksCount = 20;

            // Задаем правило выбора ориентира
            Satellite.LandmarkSelection selection = Satellite.LandmarkSelection.NEAREST;


            // Среднеквадратическая погрешность (по условию)
            //
            // Задана в угловых минутах/секундах, необходимо
            // перевести в радианы
            // 1 угловая секунда -- 1/60 угловой минуты
            // 1 угловая минута -- 1/60 градуса
            // В 180 градусах 3.14 (ПИ) радианов
            double sigma = (1.0 / 60) * (Math.PI / 180);

            // "Расставляем" ориентиры. Первый параметр показывает,
            // на сколько градусов по часосвой стрелке отклонен первый
            // ориентир от северного полюса планеты. Второй параметр
            // определяет, на сколько градусов следующий ориентир
            // отстоит от предыдущего по часовой стрелке. Третий параметр --
            // количество ориентиров.
            Landmarks.LandmarkCoords landmarkCoords = Landmarks.setLandmarksGrid(-45, 4, landmarksCount);


            // При известных начальных условиях вычисляем моменты
            // измерений и ориентиры, по которым каждое измерение
            // производится
            Satellite.Gauging[] gaugings;

            try
            {
                gaugings = Satellite.getGaugings(
                    xk_real, yk_real, vx_real, vy_real,
                    landmarkCoords.x0s, landmarkCoords.y0s,
                    interval, gaugingCount, selection
                );
            }
            catch(Satellite.CannotMakeThisManyGaugings ex)
            {
                Console.WriteLine(
                    "Невозможно выполнить {0} измерений с интервалом {1} секунд " +
                    "(КА не находится над ориентирами столько времени)",
                    gaugingCount, interval
                );
                return;
            }

            // При известных значениях оцениваемых параметров -- начальных
            // условиях -- вычисляем математическую модель вектора измерений
            // z(тета_ист), где тета_ист -- истинные значения оцениваемых
            // параметров, указанные в задании. Этот вектор обозначается D.
            double[] _D = Satellite.getZ(gaugings,
                xk_real, yk_real, vx_real, vy_real,
                landmarkCoords.x0s, landmarkCoords.y0s
            );

            // Satellite.getZ возвращает массив, но для работы с ним
            // необходимо преобразовать его в матрицу.
            Matrix D = Matrix.FromArray(_D);


            // Далее, по идее, мы забываем истинные значения оцениваемых
            // параметров, то есть начальных скоростей/координат xk_real,
            // yk_real, vx_real, vy_real, и пытаемся заново их найти при
            // помощи метода максимального правдоподобия (ММП).


            // Сформируем вектор-столбец погрешностей
            Matrix v = new Matrix(gaugingCount, 1);

            for (int i = 0; i < gaugingCount; i++)
                v[i, 0] = Gauss.Generate(sigma);

            // Получаем вектор измерений с заданными погрешностями
            Matrix R = D + v;

            // Матрица Kv^-1 -- корелляционная матрица погрешностей
            // измерений в степени (-1) -- диагональная, все элементы
            // на ее диагонали равны среднеквадратической погрешности
            // измерений в степени (-2)
            //
            // KvInv -- Kv Inverted (обратная по отношению к Kv)
            Matrix KvInv = new Matrix(gaugingCount, gaugingCount);

            for (int i = 0; i < gaugingCount; i++)
                KvInv[i, i] = Math.Pow(sigma, -2);


            // Затем пытаемся подобрать начальное приближение (первое
            // приближение, не путать с начальными условиями -- параметрами
            // движения КА) оцениваемых параметров, то есть такие значения
            // xk, yk, vx, vy, которые кажутся нам наиболее близкими к истинным
            // xk_real, yk_real, vx_real, vy_real.


            // По условию мы должны найти начальные значения координат
            // и скоростей КА на момент первого измерения.
            //
            // Предположим, что КА находится над точкой, где расположен
            // ориентир, по которому мы сделали первое измерение. Если
            // умножить координаты ориентира на число k, получим точку,
            // которая в k раз дальше от центра планеты, чем этот ориентир.
            // Например, k можно взять равным 2 или корню из 2, но, строго
            // говоря, о точном расположении КА мы ничего сказать не можем.
            //
            // Приблизительное значение скоростей (горизонтальной и вертикальной
            // скорости КА на момент первого измерения) получить еще труднее.
            // Так как не сказано, движется ли КА по эллипсу вогруг планеты,
            // или улетает от нее, мы не можем заранее определить модуль скорости.
            // Направление скорости может вообще быть каким угодно.
            //
            // Иначе говоря, определить начальное приближение в этой 
            //
            // Проблема метода максимального правдоподобия в Полунинской
            // постановке состоит в его процессе минимизации, который может не
            // только сходится не к тому минимуму, но и колебаться около
            // минимума, или вообще расходится. Поэтому незначительное отклонение
            // от истинных значений оцениваемых параметров (в нашем случае --
            // параметров движения КА) может привести к тому, что метод
            // максимального правдоподобия пойдет в разнос. Другой метод
            // поиска минимума (например, генетический алгоритм) мог бы решить
            // эту проблему.
            //
            // Если бы был найден способ определить достаточно близкое начальное
            // приближение, здесь бы был такой код:
            //
            // double xk = <первое приближение к xk_real>
            // double yk = <первое приближение к yk_real>
            // double vx = <первое приближение к vx_real>
            // double vy = <первое приближение к vy_real>
            //
            // Но из-за сказанного выше мы будем брать истинные значения оцениваемых
            // параметров с небольшими отклонениями. На поиск Парето-оптимального
            // множества это не повлияет, потому что там берется корреляционная
            // матрица погрешностей оцениваемых параметров, полученная на последнем
            // шаге, то есть когда достаточно близкие оценки параметров уже найдены.
            //
            // К начальным координатам (координатам в момент первого измерения)
            // прибавим случайную величину, распределенную по гауссовскому закону,
            // со среднеквадратическим отклонением (сигмой) 10 000 м.
            // Такая величина, с большой вероятностью, по модулю не превышает трех сигм,
            // то есть в данном случае 30 000 м, что не так много по сравнению с 6 000 000 м.
            double xk = xk_real + Gauss.Generate(10000);
            double yk = yk_real + Gauss.Generate(10000);
            // То же самое прибавим к начальной скорости, но с сигмой, равной 100 м/с.
            double vx = vx_real + Gauss.Generate(100);
            double vy = vy_real + Gauss.Generate(100);

            // Соберем оцениваемые параметры в вектор тета
            Matrix theta = new Matrix(4, 1);
            theta[0, 0] = xk;
            theta[1, 0] = yk;
            theta[2, 0] = vx;
            theta[3, 0] = vy;


            // Точность вычисления вектора оцениваемых параметров.
            // Если на каком-то шаге модуль вектора подшагивания
            // будет меньше этой величины, остановить работу ММП.
            double EPSILON = 0.1;


            // Создадим обертку над функцией Satellite.getZ такую,
            // чтобы она принимала и возвращала матрицу
            Func<Matrix, Matrix> _getZ = (Matrix _theta) =>
            {
                // Переменные здесь именуются с подчеркивания
                // только из-за ограничений языка C#
                double _xk = _theta[0, 0];
                double _yk = _theta[1, 0];
                double _vx = _theta[2, 0];
                double _vy = _theta[3, 0];

                return Matrix.FromArray(
                    Satellite.getZ(gaugings, _xk, _yk, _vx, _vy, landmarkCoords.x0s, landmarkCoords.y0s)
                );
            };


            // Корреляционная матрица погрешностей оцениваемых параметров.
            // Эта переменная используется как выходной параметр в MMP_Step
            Matrix TError = null;


            // Метод максимального правдоподобия
            for (; ; )
            {
                // Вычисляем матрицу производных
                Matrix L = MMP.getL(_getZ, theta, gaugingCount, 0.1);

                // Вызовем шаг метода максимального правдоподобия. Он
                // вернет следующее приближение вектора оцениваемых
                // параметров.
                Matrix theta1;

                try
                {
                    theta1 = MMP.MMP_Step(L, KvInv, R, _getZ(theta), theta, out TError);
                }
                catch (Matrix.DegenerationException ex)
                {
                    Console.WriteLine("Невозможно выполнить шаг ММП, так как LKv^-1L^T вырождена");
                    return;
                }

                // Запомним, насколько следующее приближение вектора оцениваемых
                // параметров отличается от текущего. Здесь мы вычисляем модуль
                // вектора подшагивания (разности следующего приближения
                // и текущего)
                double difference = (theta1 - theta).Module();

                // Теперь берем следующее приближение вектора оцениваемых
                // параметров за текущее.
                theta = theta1;

                // Если модуль вектора подшагивания меньше, чем EPSILON,
                // остановить вычисление.
                if (difference < EPSILON)
                    break;
            }

            // Вычислим погрешность, по условию она равна
            double precision = TError[2, 2] + TError[3, 3];

            // Вычислим стоимость
            double cost = equipmentCost + gaugingCost * gaugingCount + landmarkCost * landmarksCount;

            Console.WriteLine("Погрешность: " + precision + " м^2/с^2");
            Console.WriteLine("Стоимость:   " + cost + " у.е.");
        }
    }
}
