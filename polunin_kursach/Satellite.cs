using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace polunin_kursach
{
    class Satellite
    {
        const double PLANET_RADIUS = 6 * 1e6;
        const double PLANET_GRAVITY = 6;

        const double GAMMA_MASS = -PLANET_GRAVITY * PLANET_RADIUS * PLANET_RADIUS;

        const double PASSBAND = 70 * Math.PI / 180;

        public static double dx(double vx)
        {
            return vx;
        }

        public static double dy(double vy)
        {
            return vy;
        }

        public static double dvx(double x, double y)
        {
            return GAMMA_MASS * x / Math.Pow(x * x + y * y, 1.5);
        }

        public static double dvy(double x, double y)
        {
            return GAMMA_MASS * y / Math.Pow(x * x + y * y, 1.5);
        }

        static Func<double, double[], double>[] derivatives = new Func<double, double[], double>[] {
            (double x, double[] ys) => dx(ys[2]),
            (double x, double[] ys) => dy(ys[3]),
            (double x, double[] ys) => dvx(ys[0], ys[1]),
            (double x, double[] ys) => dvy(ys[0], ys[1])
        };


        public static double gamma(double xk, double yk, double x0, double y0)
        {
            // Косинус угла между вектором нормали/вертикали у планете
            // в точке нахождения ориентира и направлением на КА из
            // точки нахождения ориентира
            double cos = (x0 * (xk - x0) + y0 * (yk - y0)) /
                (Math.Sqrt(x0 * x0 + y0 * y0) * Math.Sqrt((xk - x0) * (xk - x0) + (yk - y0) * (yk - y0)));

            // Косинус угла может немного не попадать в отрезок [-1; 1]
            // вследствие вычислительной погрешности, в этом случае его
            // необходимо округлить до ближайшего целого, которым будет
            // -1 или 1
            if (Math.Abs(cos) > 1)
                cos = Math.Round(cos);

            return Math.Acos(cos);
        }

        public static bool inBand(double xk, double yk, double x0, double y0)
        {
            return gamma(xk, yk, x0, y0) <= PASSBAND;
        }


        public static double phi(double xk, double yk, double x0, double y0)
        {
            return Math.Acos((xk * (xk - x0) + yk * (yk - y0)) /
                (Math.Sqrt(xk * xk + yk * yk) * Math.Sqrt((xk - x0) * (xk - x0) + (yk - y0) * (yk - y0))));
        }


        // Структура, описывающая, в какой момент времени и по какому ориентиру
        // производится отдельное измерение, а также его результат -- значение
        // угла ФИ
        public struct Gauging
        {
            // Конструктор структуры
            //
            // Создан для того, чтобы не присваивать поля 
            // по отдельности
            public Gauging(double t, int landmark, double phi)
            {
                this.t = t;
                this.landmark = landmark;
                this.phi = phi;
            }

            // Момент времени, в который делается данное измерение
            public double t;

            // Номер (индекс) ориентира(landmark), по которому делается
            // данное измерение
            public int landmark;

            // Результат измерения -- угол ФИ относительно ориентира
            // landmark в момент времени t
            public double phi;
        }


        // Принцип выбора(selection) ориентира(landmark), по которому
        // проводить измерение, если в данный момент времени можно
        // провести измерение по одному из нескольких ориентиров
        public enum LandmarkSelection
        {
            // Выбирается ориентир, по отношению к котрому
            // угол ГАММА наименьший. Предполагается, что
            // такой ориентир находится ближе всего(nearest)
            // к КА. Соответствует ситуации в задании, когда
            // угол измеряется сначала по одному, затем по
            // другому ориентру.
            NEAREST,

            // Ориентиры выбираются поочередно (alternate).
            ALTERNATE
        }


        // Функция, возвращающая моменты времени, в которые выполняются
        // измерения, по какому ориентиру измерение каждое измерение
        // выполняется, а также его результат, при заданных условиях,
        // передаваемых через параметры: начальных координатах и скоростях
        // КА, координатах ориентиров, интервале измерений и методе
        // выбора ориентира, по которому нужно делать измерение, если
        // в данный момент можно выполнить измерение по нескольким ориентирам.
        //
        // Также задается count -- планируемое количество измерений. Если
        // за время, в течение которого КА находится над ориентирами, такое
        // количество измерений выполнить невозможно, функция порождает
        // исключение
        //
        // Возвращает массив Gauging, то есть массив записей вида
        // <время, номер ориентира, угол ФИ>
        //
        // xk, yk -- координаты КА в условный момент времени 0
        // vx, xy -- скорости КА в условный момент времени 0
        // x0s, y0s -- координаты ориентиров: x0s -- абсциссы, y0s -- ординаты
        // interval -- интервал времени, с которым производятся измерения
        // count -- количество измерений, которое планируется выполнить
        // selection -- какой ориентир выбрать для измерения, если КА находится
        // в области, где угол ГАММА не превышает 70 градусов для нескольких
        // ориентиров
        public static Gauging[] getGaugings(
            double xk, double yk, double vx, double vy,
            double[] x0s, double[] y0s,
            int interval, int count,
            LandmarkSelection selection
        ) {
            // Результат заносится сюда -- в массив из count измерений
            Gauging[] gaugings = new Gauging[count];


            // Сколько измерений уже сделано(done)
            //
            // Когда равно планируемому количеству измерений count,
            // цикл поиска моментов измерений завершается
            //
            // В массиве gaugings показывает индекс, куда записывать
            // момент, ориентир и результат следующего измерения
            //
            // Если измерения производятся поочередно по нескольким
            // ориентирам (selection === ALTERNATE), позволяет
            // поочередно менять ориентиры
            int done = 0;


            // За количество(count) ориентиров(LandMark) примем длину
            // массива абсцисс ориентиров
            int lmCount = x0s.Length;


            // В какие моменты времени вычислять (с каким шагом
            // интегрировать) уравнения движения КА для вычисления
            // его положения во время следующего измерения (через
            // интервал измерений interval)
            //
            // Начинается с нуля, а не с текущего времени t, так
            // как RungeCutta.Integrate берет только разности 
            // между моментами времени xs[1] - xs[0], xs[2] - xs[1], ...
            //
            // Таким образом, [0, 1, 2, ..., interval] эквивалентно
            // [t, t + 1, t + 2, ..., t + interval] с точки зрения
            // RungeCutta.Integrate. Если передать в RungeCutta.Integrate
            // [0, 1, 2, ..., interval] и координаты/скорости КА на
            // момент времени t, то вактически будут вычислены
            // координаты/скорости в моменты [t, t + 1, t + 2, ...,
            // t + interval]
            double[] xs = new double[interval + 1];

            for (int sec = 0; sec <= interval; sec++)
                xs[sec] = sec;


            // Текущий момент времени, показывает время модели,
            // прошедшее с начального момента, для которого начальные
            // координаты и скорости КА заданы извне (переданы через
            // параметры)
            //
            // В начальный момент времени t = 0
            double t = 0;


            for (; ; )
            {
                // В этот список будут помещаться номера ориентиров, над
                // которыми сейчас (при текущем значении t) пролетает КА
                //
                // По идее эту переменную нужно было назвать "availableLandmarks"
                // (доступные ориентиры), но для краткости она называется просто
                // landmarks
                //
                // КА пролетает над ориентиром -- то есть находится в данный
                // момент в области, для которой угол ГАММА относительно
                // данного ориентира не  превышает 70 градусов
                //
                // (где, согласно заданию, измерения могут быть проведены без
                // дополнительных погрешностей -- из других точек мы просто
                // не будем делать измерения)
                List<int> landmarks = new List<int>();

                for (int lm = 0; lm < lmCount; lm++)
                    if (inBand(xk, yk, x0s[lm], y0s[lm]))
                    {
                        // Внесем lm -- номер (индекс) ориентира в список
                        landmarks.Add(lm);
                    }

                // Если КА сейчас пролетает хотя бы над одним из ориентиров,
                // записать данный момент времени и выбрать ориентир, по
                // которому сейчас должно быть выполнено измерение угла ФИ
                //
                // Угол ФИ -- измеряемая величина
                if (landmarks.Count > 0)
                {
                    // Номер (индекс) выбранного ориентира в списке всех ориентиров
                    //
                    // Самого списка всех ориентиров нет, под ним подразумеваются
                    // массивы x0s/y0s координат ориентиров
                    int selectedLandmark;

                    // При поочередном выборе ориентиров
                    if (selection == LandmarkSelection.ALTERNATE)
                    {
                        // Из доступных ориентиров выберем доступный ориентир с
                        // индексом, равным остатку от деления количества сделанных
                        // измерений done на количество доступных ориентиров
                        // landmarks.Count. Результат деления будет одним из
                        // {0, 1, 2, ..., landMarks.Count - 1}, каждое из этих
                        // чисел является допустимым индексом в списке доступных
                        // ориентиров. Так как done на следующей итерации увеличится
                        // на единицу, то при таком же множестве ориентиров, над
                        // которыми пролетает КА, будет выбран следующий ориентир.
                        // При небольшом интервале измерений множество ориентиров,
                        // над которыми пролетает КА в момент следующего измерения,
                        // с большой вероятностью останется таким же.
                        //
                        // Индекс выбранного ориентира в списке доступных ориентиров
                        // (над которыми сейчас пролетает КА)
                        int selectedLandmarkInAvailableLandmarks = done % landmarks.Count;

                        // По индексу выбранного ориентира в списке доступных
                        // ориентиров найдем индекс этого ориентира в списке всех
                        // ориентиров.
                        selectedLandmark = landmarks[selectedLandmarkInAvailableLandmarks];
                    }
                    // Иначе выбираем ориентир, для которого угол ГАММА в текущий
                    // момент времени наименьший.
                    //
                    // Значение selection может быть только NEAREST, если оно
                    // не равно ALTERNATE, поэтому проверять
                    // if (selection == LandmarkSelection.ALTERNATE) не нужно.
                    else
                    {
                        // Сначала положим выбранный ориентир равным первому из
                        // доступных; хотя бы один доступный ориентир есть (на
                        // это была проверка if (landmarks.Count > 0))
                        int nearestLandmark = landmarks[0];

                        // Сравним угол ГАММА для этого ориентира с углами ГАММА
                        // для всех остальных доступных ориентиров.
                        //
                        // Проходим по всем остальным доступным ориентирам
                        for (int lm = 1; lm < landmarks.Count; lm++)
                        {
                            // Индекс другого(another) ориентира в списке всех ориентиров
                            int anotherLandmark = landmarks[lm];

                            // Если угол ГАММА для другого ориентира anotherLandmark
                            // меньше, чем для выбранного nearestLandmark
                            if (gamma(xk, yk, x0s[anotherLandmark], y0s[anotherLandmark]) <
                                gamma(xk, yk, x0s[nearestLandmark], y0s[nearestLandmark])
                                )
                                // Тогда выберем другой ориентир anotherLandmark.
                                nearestLandmark = anotherLandmark;
                        }

                        // Будет выбран ориентир, по отношению к которому угол ГАММА сейчас
                        // наименьший.
                        selectedLandmark = nearestLandmark;
                    }

                    // Запишем текущий момент времени t, выбранный ориентир
                    // selectedLandmark и результат измерения по отношению
                    // к нему угла ФИ в массив
                    gaugings[done] = new Gauging(t, selectedLandmark,
                        phi(xk, yk, x0s[selectedLandmark], y0s[selectedLandmark]));

                    // После записи измерения в массив, счетчик измерений
                    // инкрементируется
                    done++;

                    // Отладочный вывод, убрать к чертям собачим
                    Console.WriteLine("{5,4} {6,4} {0,8} {1,13:f} {2,13:f} {3,13:f} {4,13:f}",
                        String.Format("{0}:{1:00}", (int)t / 60 / 60, (int)t / 60 % 60),
                        gamma(xk, yk, x0s[selectedLandmark], y0s[selectedLandmark]) * 180 / Math.PI,
                        phi(xk, yk, x0s[selectedLandmark], y0s[selectedLandmark]) * 180 / Math.PI,
                        Math.Atan2(yk, xk) * 180 / Math.PI,
                        Math.Sqrt(xk * xk + yk * yk) - PLANET_RADIUS,
                        done,
                        selectedLandmark
                    );
                }


                // Если количество сделанных измерений done равно
                // планируемому count, можно завершать процедуру
                // поиска моментов измерений
                if (done == count)
                    break;


                // Процесс может зацикливаться, если есть такой ориентир, над
                // которым КА не пролетает
                //
                // Введем условие остановки вычислений по времени модели t
                //
                // Положим t равным одним суткам, можно выбрать и другую величину
                //
                // maxTime должно быть не меньше interval * (count - 1) -- наименьшее
                // время, за которое можно выполнить планируемое число измерений, так
                // что при значительном увеличении интервала и количества измерений,
                // maxTime также следует увеличить (изменив следующую строку)
                const double maxTime = 1 * 24 * 60 * 60;

                // Если текущее время (в модели) больше maxTime, то планируемое
                // количество измерений точно не было выполнено до этого момента, иначе
                // бы цикл прервался по условию done == count. Следовательно,
                // планируемое количество измерений за достаточно большой отрезок
                // времени ([0; maxTime]) осуществить нельзя.
                if (t > maxTime)
                    throw new CannotMakeThisManyGaugings();


                // Находим координаты/скорости КА по прошествии интервала измерений
                // (на момент t + interval)
                double[,] nextPosition =
                    RungeCutta.Integrate(derivatives, new double[] { xk, yk, vx, vy }, xs);

                // Обновляем текущие значения координат/скоростей
                // Значения координат/скоростей на последнем шаге интегрирования
                // соответствуют значениям через интервал interval (интервал между
                // измерениями). В массиве nextPosition первый индекс соответствует
                // индексу момента интегрирования, а второй индекс -- индекс уравнения
                // в системе. Так как всего моментов интегрирования interval + 1
                // (моменты интегрирования -- [0, 1, 2, ..., interval]), то индекс
                // последнего измерения равен interval.
                xk = nextPosition[interval, 0];
                yk = nextPosition[interval, 1];
                vx = nextPosition[interval, 2];
                vy = nextPosition[interval, 3];

                // Обновляем текущее время, так как мы вычислили координаты/скорости КА
                // через интервал измерений interval
                t += interval;
            }

            // Возвращаем вычисленные моменты измерений и номера ориентиров, по
            // которым каждое из измерений производится
            return gaugings;
        }

        public class CannotMakeThisManyGaugings : Exception { }
    }
}
